---
title: "Blog Demo"
date: "2025-12-07"
excerpt: "掌握 useEffect 和 useState，以控制应用程序中的时间和状态流。"
xp: 500
level: "新手村"
readTime: "5 分钟阅读"
image: "/images/blog/cover.jpeg"
gif: "/images/blog/cover.jpeg"
---

# React Hooks 的传说

很久以前，在类组件王国中，状态被困在复杂的 `this` 绑定和生命周期方法中。开发人员很难在组件之间共享逻辑，导致了可怕的 **嵌套地狱 (Wrapper Hell)**。

然后 **Hooks** (v16.8) 出现了，这是一套神奇的神器，允许函数组件运用状态和副作用的力量。

## 1. 抓钩 (Hookshot): useState

这是你库存中最基本的工具。它允许你在渲染之间持久保存值。

```javascript
const [health, setHealth] = useState(100);

// 受到伤害
setHealth(prev => prev - 10);
```

## 2. 时间宝石: useEffect

控制副作用——获取数据、订阅或手动更改 DOM。它取代了 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`。

```javascript
useEffect(() => {
  const timer = setInterval(() => {
    console.log("滴答...");
  }, 1000);

  return () => clearInterval(timer); // 清理阶段
}, []);
```

### Hooks 的关键规则
1. 只在顶层调用 Hooks。
2. 只在 React 函数组件中调用 Hooks。
3. 不要在循环、条件或嵌套函数中调用 Hooks。

> "能力越大，责任越大。别忘了依赖数组！" - 长老开发者

## 流程可视化

![Flow test](https://placehold.co/600x200/0f172a/FFF?text=Render+Cycle+Visualized)

## 自定义 Hooks

你可以通过组合现有的 hook 来制作你自己的武器。这是函数式范式的真正力量。

- **useWindowSize**: 跟踪视口尺寸。
- **useLocalStorage**: 将状态持久化到浏览器存储。
- **useFetch**: 简化的数据获取。

掌握这些工具，你将征服前端领域！
